
\chapter{Design and implementation}

\section{Improving extensibility and coverage}
\label{label:addtest}

\subsubsection{Test management interface}

We needed to add tests..
we discussed what functions we needed
decided to just do categories manually , explained how we made it okay design-wise with the .sql file we expect to be filled with all new categories.
what can we do to add tests , we had to alter
given the way the context of tests work we can run any js and call test PASS and FAIL.. or call any of the existing ones

the UI

reusing existing server code

handling static assets

\subsubsection{Adding new tests}

we start simple, because simple is beautiful. The simplest types of tests we could thing of required a new category: Client-only tests.
These tests do not require interaction from the server, except for reporting the results for a particular test execution.

we are talking mainly about javascript tests, postmessage on local frames, navigation in same window for example.

these tests are self-explanatory and allows us to guage the external quality of our test adding interface progressively, meaning first only needing
to add client code to the database and registering the results of their execution on the client, bypassing the need to setup endpoints with particular types
of responses or other complex configuration. 

\emph{Strict mode javascript tests}

The first test we're going to include deals with Strict Mode, it is a new feature in ECMAScript 5 that allows you to place a program, \
or a function, in a "strict" operating context. This strict context prevents certain actions from being taken and throws more exceptions.\
to use this feature suffice it to add the  "use strict"; keyword at the top of the page , or very conveniently in our case , in the context \
of a function only. Using strict mode allows to raise errors on using certain bad practices of ES3 which ES5 is normally fully retroactively compatible with.\

What is not allowed in strict mode, according to \cite{resig}:
\begin{itemize}
 \item use of implicit or undefined globals will result in error.
 \item Deleting a variable, a function, or an argument will result in an error, instead of silently failing.
 \item defining a property more than once in an object literal will cause an exception to be thrown.
 \item Virtually any attempt to use the name ‘eval’ is prohibited – as is the ability to assign the eval function to a variable or a property of an object.
 \item Additionally, attempts to introduce new variables through an eval will be blocked.
 \item with(){} is a syntax error.
\end{itemize}

Since all of these are restrictions, we will trust that it doesn't over restrict and will just test for negative properties for each of these prohibited behaviour.\

Hence, our first test is:

\begin{verbatim}
 (function(){
  "use strict";
  try{
    bignametoavoidclash = 'initialising a global, -10000 marks!';
  }
  catch(bro){
    this.PASS("exception was raised, this is the desired behaviour");
  }
  this.FAIL("the exception was not thrown, ES5 strict mode globals are not properly implemented");
 }());
\end{verbatim}

\section{statistics page}

\section{Strech Goal: A DSL for test inputting and parameterisation }