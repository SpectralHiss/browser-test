\chapter{Design and implementation}

\section{Improving extensibility and coverage}
\label{label:addtest}

\subsection{Test management interface}

The first thing that was deemed crutial to extend browseraudit was to enable the adding of tests in a convenient manner, this section will
guide you through the components we needed to build this interface and what design choices entail in our implementation.
At this point it is important for understanding this project to review appendix \ref{app:A}. in particular to understand
the structure of the application and have a rough picture of the data model. 

\subsubsection{Scoping}

At the time of project handover there were no more than 5 top categories and a total of under 40 categories and subcategories.
in light of prioritising time, our first scoping choice was not to pursue the feature that would allow the user to add categories through our interface.

Indeed, our final implementation forces developers to manually add categories, and we had to do this for one new category and subcategory.
we did this manually but in a future proof way, by making the new categories explicit queries in a database migration file (or .sql file) in order to transparently allow setup on new
servers or cross developement database servers.

This allows us to focus on the most important part which is the working principle of adding tests to browseraudit with the least pain possible.

The other scoping choice was regarding what the domain of tests that we could add to our interface. As explained in \ref{label:workprinc}, 
in order for tests to run , go server functions are setup for each particular kind of category. 

\subsubsection{What our test interface can do}

Currently, our test interface allows you to choose a particular (sub) category , enter a title , test function , timeout and add the test to the database.
It also has a template function fetcher which fetches the test template function for that category along with example usage from the tests that are already in the database.
A quick reminder of template functions: they are the generic functions that categories use to test a particular function, usually following a particular
endpoint pattern on the server or variations on the same headers.

In order to allow this , model wise we had to alter the test function invocation field of our test to be able to hold arbitrarily long javascript text.
The technical working principle of how tests added in this manner eventually run is explained quite precisely in \ref{subsec:princ}. 



\subsubsection{Test working principle}
\label{subsec:princ}

So far you've seen that our test interface can add new test functions, let's first show how you would descibe a new test function in our interface:
Among the many boxes you are presented in the test management interface is the add test function box which contains a code editing textarea with the following
text already in place:
\begin{verbatim}
function(){
// this function is called with a context containing
// three functions, PASS, WARNING , CRITICAL or SKIP, usage:

	this.WARNING("Reason for the warning");
/*
 alternatively you can make calls to one of the 
 below functions like cspTest(foo, bar ,jah); 
 for any category you can get the template function below
*/} 
\end{verbatim}

This works because this function body that is saved to the database is loaded as the testFunciton object in the below text.
Which is invoked with the call method of the Function object , it is called in this manner in order to allow specification
of the "this" context to be the object containing the PASS, WARNING , CRITICAL and SKIP functions that are used above. 

\begin{verbatim}
// Execute the test function, using a "test harness" object as the
		// context (i.e. the "this" object)
		thisNode.testFunction.call({
			PASS: function(reason) { markHierarchyNode(thisNode.nodeType, thisNode.id, testStartTime, [ "pass", reason ], testTimer); },
			WARNING: function(reason) { markHierarchyNode(thisNode.nodeType, thisNode.id, testStartTime, [ "warning", reason ], testTimer); },
			CRITICAL: function(reason) { markHierarchyNode(thisNode.nodeType, thisNode.id, testStartTime, [ "critical", reason ], testTimer); },
			SKIP: function(reason) { markHierarchyNode(thisNode.nodeType, thisNode.id, testStartTime, [ "skip", reason ], testTimer); }
		});
	      
\end{verbatim}

Of course this loose way of passing functions is dangerous , we make sure that it is a valid function before  committing to database.
we do this on the client side because we assume we trust the developer will only make mistakes and not maliciously send to this 
protected endpoint (with HTTP Auth.)

you can put arbitrary html for the reason for test, but we prefer users stick to simple text to avoid any issues, 
The test framework is robust enough to, as long as the minimal structure of a test is sound gracefully skip problematic entries in case of error.

You can see from the above text that you have the convenience of reusing any of the template functions that are already in place for other categories
this is very good news for extensibility in browseraudit. The only missing part is some way of dealing with browsing and adding html templates
to use along those functions, to which unfortunately we don't have a current way of doing but is an easy thing to add in the future and we
can already tinker manually to find these by browsing the server folder directories corresponding to tests like /sop/ajax.html (for example).

\subsubsection{User Interface}

the UI was made using knockoutjs \cite{knockoutjs} library a Model-View-View Model pattern, it has proven to be a very powerful framework that once mastered allowed
to avoid the trouble that dealing with complex HTML and events can become. The result is a pretty easy to use minimalistic interface. We decided
to go for the main bootstrap theme for style which makes the page well presentable and readable and mobile friendly out of the box.
you can see a snapshot of the interface in :



\subsubsection{Reusing server code}
setup for the future
reusing existing server code

\subsubsection{Adding new tests}

we start simple, because simple is beautiful. The simplest types of tests we could thing of required a new category: Client-only tests.
These tests do not require interaction from the server, except for reporting the results for a particular test execution.

we are talking mainly about javascript tests, postmessage on local frames, navigation in same window for example.

these tests are self-explanatory and allows us to guage the external quality of our test adding interface progressively, meaning first only needing
to add client code to the database and registering the results of their execution on the client, bypassing the need to setup endpoints with particular types
of responses or other complex configuration. 

\emph{Strict mode javascript tests}

The first test we're going to include deals with Strict Mode, it is a new feature in ECMAScript 5 that allows you to place a program, \
or a function, in a "strict" operating context. This strict context prevents certain actions from being taken and throws more exceptions.\
to use this feature suffice it to add the  "use strict"; keyword at the top of the page , or very conveniently in our case , in the context \
of a function only. Using strict mode allows to raise errors on using certain bad practices of ES3 which ES5 is normally fully retroactively compatible with.\

What is not allowed in strict mode, according to \cite{resig}:
\begin{itemize}
 \item use of implicit or undefined globals will result in error.
 \item Deleting a variable, a function, or an argument will result in an error, instead of silently failing.
 \item defining a property more than once in an object literal will cause an exception to be thrown.
 \item Virtually any attempt to use the name ‘eval’ is prohibited – as is the ability to assign the eval function to a variable or a property of an object.
 \item Additionally, attempts to introduce new variables through an eval will be blocked.
 \item with(){} is a syntax error.
\end{itemize}

Since all of these are restrictions, we will trust that it doesn't over restrict and will just test for negative properties for each of these prohibited behaviour.\

Hence, our first test is:

\begin{verbatim}
 function(){
  "use strict";
  try{
    bignametoavoidclash = 'initialising a global, -10000 marks!';
  }
  catch(bro){
    this.PASS("exception was raised, this is the desired behaviour");
  }
  this.FAIL("the exception was not thrown, ES5 strict mode globals are not properly implemented");
 }
\end{verbatim}

\section{statistics page}

formatting the data properly.


the UI 


\section{Open ended Goal: Data-driven browser security reference for the developer }